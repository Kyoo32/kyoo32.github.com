{"componentChunkName":"component---src-templates-blog-post-js","path":"/swiftUIEssential2/","result":{"data":{"site":{"siteMetadata":{"title":"KyooBlog"}},"markdownRemark":{"id":"fe2f0653-ca6e-5516-8160-e1d2737f8925","excerpt":"This is the summary of WWDC20 Session ‘Data essentials in SwiftUI(10040)‘. Data Essentials When I start on a new view in SwiftUI there are three key questions I…","html":"<blockquote>\n<p>This is the summary of WWDC20 Session ‘Data essentials in SwiftUI(10040)‘.</p>\n</blockquote>\n<h5>Data Essentials</h5>\n<blockquote>\n<p>When I start on a new view in SwiftUI there are three key questions I like to think about. </p>\n</blockquote>\n<h6>Three Key Questions</h6>\n<ul>\n<li>What does this view need to do its jos?</li>\n<li>How will the viw manipulate that data?</li>\n<li>\n<p>Where will the data come from? (Source of Truth)</p>\n<ul>\n<li>\n<p>This question of the Source of Truth is the most important one in the design of your data model.</p>\n<h6>State&#x26;Binding</h6>\n</li>\n</ul>\n</li>\n<li>\n<p>State: the simplest Source of Truth in SwiftUI</p>\n<ul>\n<li>State is designed for transient UI state that is local to a view.</li>\n<li>When we mark this property as state SwiftUI takes over managing its storage. Why is that important? Well remember that our views only exist transiently. After SwiftUI completes a rendering pass the structs themselves go away. But because we mark this property as state, SwiftUI maintains it for us. The next time the framework needs to render this view it reinstantiates the structs and reconnects it to the existing storage. </li>\n<li>Remember State creates a new Source of Truth.</li>\n</ul>\n</li>\n<li>\n<p>Binding: the tool for sharing right access to any Source of Truth</p>\n<ul>\n<li>Because some is a value type, Swift would make a new copy of the value. Any changes the view made to the value would only change this new copy, not the original value that SwiftUI is managing for us. So this doesn’t allow the view to communicate with superview. We need a way to share right access to the Source of Truth.</li>\n<li>The dollar sign in the call creates a binding from the state because the projected value of the state property wrapper is a binding. The binding property wrapper creates a data dependency between subviews and superviews. Many built-in SwiftUI controls also take bindings. </li>\n<li>Remember bindings aren’t just for state.</li>\n</ul>\n</li>\n</ul>\n<h6>Designing Custom Model</h6>\n<ul>\n<li>\n<p>When you should use ObservableObject</p>\n<ul>\n<li>Need a data model which is separate from its UI</li>\n</ul>\n</li>\n<li>\n<p>How ObservableObject is defined</p>\n<ul>\n<li>It’s a class constraint protocol which means it can only be adopted by reference types.</li>\n<li>It has a single requirement: an objectWillChange property. ObjectWillChange is a Publisher, and as the name suggests, the semantic requirement of the ObservableObject protocol is that the publisher has to emit before any mutation is applied to the object.</li>\n<li>By default you get a publisher that works great out of the box but if you need to you can provide a custom publisher.</li>\n</ul>\n</li>\n<li>\n<p>The mental model</p>\n<ul>\n<li>When your type conforms to ObservableObject you are creating a new Source of Truth and teaching SwiftUI how to react to changes. In other words you are defining the data that the view needs to render its UI and perform its logic. SwiftUI will establish a dependency between your data and your view.</li>\n</ul>\n</li>\n<li>\n<p>Data dependency surface</p>\n<ul>\n<li>SwiftUI uses this dependency to automatically keep your view consistent and show the correct representation of your data.</li>\n<li>This is the part of your model that exposes data to your view but is not necessarily the full model. You can separate your data from its storage and lifecycle. You can model your data using value type and manage its lifecycle inside effect with a reference type.  this gives you a single place for all your logic making it easy to reason about all the possible state and mutation in your app.</li>\n<li>Or you can focus on part of your app by having multiple ObservableObject that offer a specific projection onto your data model and are designed to expose just the data that is needed. This works better when you have a complex data model and you want to provide a more tightly scoping validation to part of your app.</li>\n</ul>\n</li>\n<li>\n<p>@Published property wrapper</p>\n<ul>\n<li>be able to update the progress and have our UI react to it.</li>\n<li>by publishing right before the value changes. : SwiftUI needs to know when something is about to change so that it can coalesce every change into single update.</li>\n<li>For advanced use case the projected value of @Published is a publisher that you can use to build reactive streams.</li>\n</ul>\n</li>\n<li>\n<p>a dependency to an ObservableObject </p>\n<ul>\n<li>three property wrapper that you can use in a view to create.</li>\n<li>ObserveObject: a property wrapper that you can use to annotate properties of your view that hold a type conforming to ObservableObject. This is the most simple and flexible of the tool. ObservedObject does not get ownership of the instance you’re providing to it. It’s your responsibility to manage its lifecycle.</li>\n<li>StateObject: The instance that is assigned to this property is going to be the Source of Truth for this view. Now we can read the model in the view body. SwiftUI will guarantee that the view is always up to date. You can just declaratively describe how to drive the view from the data and SwiftUI will take care of all the rest.</li>\n<li>\n<p>EnvironmentObject: both a view modifier and a property wrapper</p>\n<ul>\n<li>You use the view modifier in a parent view where you want to inject an ObservableObject. And you use the property wrapper in all the views where you want to read an instance of that specific ObservableObject.</li>\n<li>You need to use your ObservableObject in a distant subview and passing it down through views that don’t need the data.</li>\n<li>The framework will take care of passing that value everywhere it’s needed and track it as a dependency only where it is read.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>The lifecycle of your ObservableObject</p>\n<ul>\n<li>ObserveObject does not own the lifecycle of its ObservableObject.</li>\n<li>You provide the initial value and SwiftUI will instantiate that value just before running body for the first time. You don’t need to fiddle with OnDisappear anymore.</li>\n<li>SwiftUI will keep the object alive for the whole lifecycle of the view.</li>\n</ul>\n</li>\n</ul>\n<h6>Techniques For Integrating Data Model Into App</h6>\n<ul>\n<li>\n<p>View Update Life Cycle</p>\n<ul>\n<li>SwiftUI uses view to create a rendering, and then it’s gone. </li>\n<li>View structs do not have a defined lifetime. The lifetime of a view is separate from the lifetime of the struct that defines it. The struct you create that conforms to the view protocol actually has a very short lifetime.</li>\n<li>The diagram below shows the SwiftUI update lifecycle. Starting at the top, we have your UI. Moving counterclockwise, an event comes in, which causes some closure or action to run. That then results in a mutation of a Source of Truth. Then once we’ve mutated the Source of Truth, we’ll get a new copy of the view, which we’ll use to produce a rendering. That rendering is your UI.</li>\n<li>A slow update:  if there’s expensive, blocking work at any of these points, the performance of your app will suffer. You might drop frames or your app might hang. Avoid Slow Updates</li>\n<li>\n<p>Event sources; These triggers are called event sources.</p>\n<ul>\n<li>Regardless of what triggers the event, the cycle is still the same. We’ll mutate a Source of Truth, update the view, and then produce a new rendering.</li>\n<li>Each of these modifiers takes a parameter such as a publisher or a value to compare. And it also takes a closure. SwiftUI will run the closure at the right time to help you avoid slow updates and keep body cheap.</li>\n<li>SwiftUI will run these closures on the main thread, so if you need to do expensive work, consider dispatching to a background queue.</li>\n</ul>\n</li>\n<li>An important question to ask is “who owns the data?”</li>\n<li>\n<p>Summary: Source of Truth Lifetime</p>\n<ul>\n<li>Views are a great tool to tie your data lifetime to. And all of the property wrappers we’ve discussed today work with Views. You can make use of the State and StateObject property wrappers to tie data lifetime to View lifetime.</li>\n<li>SwiftUI’s Scenes each have a unique view tree, you can hang important pieces of data off the root of the tree. This works great with multiple windows.</li>\n<li>what’s great about Apps is that you can use State and other Sources of Truth in an App just like you do in a View. Here we’ll create a global book model for our entire app by using the StateObject property wrapper.</li>\n<li>Process lifetime:  they’re tied to the process lifetime. If your app gets killed, or the device restarts, State won’t come back</li>\n<li>\n<p>These have an extended lifetime and are saved and restored automatically. Note these are not your model.</p>\n<ul>\n<li>SceneStorage is a per-Scene scoped property wrapper that reads and writes data completely managed by SwiftUI. We’ll pass a key, which must be unique to the type of data we’re storing. Then, we can use it just like State.  behaves like State it’s a scene-wide Source of Truth.</li>\n<li>AppStorage: This is app-scoped global storage which is persisted using user defaults. It’s usable from anywhere. AppStorage, like user defaults, is super useful for storing small bits of data, such as settings.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h6>Bottom Line</h6>\n<p>It’s important to think about what the properties of your data are and what the right Source of Truth to use is. And you should also try and limit the number of Sources of Truth to cut down on complexity. Remember, bindings are completely agnostic to their Source of Truth, which makes them a powerful tool for building clean abstractions.</p>","frontmatter":{"title":"Data Essentials In SwiftUI","date":"August 10, 2020","description":"This summarizes WWDC20 Session 'Data essentials in SwiftUI(10040)'"}}},"pageContext":{"slug":"/swiftUIEssential2/","previous":{"fields":{"slug":"/swiftUIEssential/"},"frontmatter":{"title":"App Essentials In SwiftUI"}},"next":null}}}