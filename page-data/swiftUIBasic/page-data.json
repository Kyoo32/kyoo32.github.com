{"componentChunkName":"component---src-templates-blog-post-js","path":"/swiftUIBasic/","result":{"data":{"site":{"siteMetadata":{"title":"KyooBlog"}},"markdownRemark":{"id":"a2495313-4ef5-5005-9d90-667350502e7a","excerpt":"This is the summary of WWDC20 Session ‘ntroduction to SwiftUI(10119)‘. The way SwiftUI works A view is a struct It conforms to the view protocol, rather than a…","html":"<blockquote>\n<p>This is the summary of WWDC20 Session ‘ntroduction to SwiftUI(10119)‘.</p>\n</blockquote>\n<h5>The way SwiftUI works</h5>\n<ol>\n<li>\n<p>A view is a struct</p>\n<ul>\n<li>It conforms to the view protocol, rather than a class that inherits from a base  class like UIView. This means your view doesn’t inherit any stored properties. It’s allocated on the stack, and it’s passed by value.</li>\n<li>no additional allocation or reference counting</li>\n</ul>\n</li>\n<li>\n<p>Small, single-purpose views</p>\n<ul>\n<li>Behind the scenes, SwiftUI aggressively collapses your view hierarchy into an efficient data structure for rendering.</li>\n</ul>\n</li>\n<li>\n<p>Views are incredibly lightweight in SwiftUI.</p>\n<ul>\n<li>Because extracting a subview has virtually no runtime overhead</li>\n</ul>\n</li>\n<li>\n<p>The same primary role of View: they define a piece of UI.</p>\n<ul>\n<li>A view in SwiftUI and a view in a traditional UI framework fulfill the same primary role: they define a piece of UI.</li>\n<li>The view protocol only requires a single property: body. Which is itself a view. The rendering of any view you might build, like SandwichDetail, is just the rendering of its body.</li>\n</ul>\n</li>\n<li>\n<p>A view defines its dependencies.</p>\n<ul>\n<li>When SwiftUI sees a view with a state variable, it allocates persistent storage for that variable on the view’s behalf. One of the special properties of state variables is that SwiftUI can observe when they’re read and written. Because SwiftUI knows that zoomed here was read in body, it knows that the view’s rendering depends on it.</li>\n<li>when the variable changes, the framework is going to ask for the body again, using that new state value so it can refresh the rendering. Traditional UI frameworks don’t distinguish between state variables and plain old properties. However, I found the distinction to be incredibly clarifying.</li>\n</ul>\n</li>\n<li>\n<p>In SwiftUI, every possible state your UI might find itself in an authoritative piece of data often called “a source of truth.”</p>\n<ul>\n<li>Collectively, your state variables and your model constitute the source of truth for your entire app.</li>\n<li>For example, the offset of a scroll view, the highlightness of a button, the contents of a navigation stack…</li>\n</ul>\n</li>\n<li>\n<p>You can neatly classify every property as either a source of truth or a derived value.</p>\n<ul>\n<li>Recall, SwiftUI can observe when state variables are read and written. So when one changes, it knows which renderings to refresh. The framework refreshes a rendering by asking for a new body, making a new aspectRatio view from scratch, thereby overriding the contentMode and any other stored properties. This is the mechanism by which all derived values are kept up-to-date in SwiftUI.</li>\n</ul>\n</li>\n<li>\n<p>Read/Write&#x26;SourceOfTruth/DerivedValue</p>\n<ul>\n<li>Every state variable is a read-write source of truth.</li>\n<li>Every plain old property is a read-only derived value.</li>\n<li>SwiftUI invents a tool called “binding” for passing read-write derived values.</li>\n<li>Constant can serve as a perfectly good read-only source of truth.</li>\n<li>Observable objects: your state variables and your model constitute the source of truth of your entire app</li>\n</ul>\n</li>\n<li>\n<p>SwiftUI automatically manages dependencies on your behalf, recomputing the appropriate derived values so this never happens again.</p>\n<ul>\n<li>In a traditional UI framework, every time a view reads a piece of data, it’s creating an implicit dependency. It’s a dependency because when that data changes, the view needs to update to reflect the new value. When it fails to, that’s a bug.</li>\n<li>These kinds of mistakes are easy to make when you mutate your subviews directly in event handler callbacks rather than updating a source of truth and deriving your UI from that. The challenge of managing this complexity should be familiar to anyone who has tried to juggle asynchronous callbacks or implement interruptible animations. These completion handlers can fire at all kinds of unexpected times.</li>\n</ul>\n</li>\n</ol>\n<h5>Outro</h5>\n<p>No one pretends synchronizing multi-threaded code is easy. Race conditions and UI inconsistencies share the same underlying source of complexity. Many of the views we all work on have to handle way more than four events. Model notifications, target-actions, delegate methods, lifecycle checkpoints, completion handlers— they’re all events</p>\n<p>You’re human. You can only fit so much in your head at a time. As we add features the number of possible orderings explodes, and the chance we overlook one increases to the point where bugs are inevitable.</p>\n<p>When using a traditional UI framework the simplicity that results from collecting all of your view updates into a single method. When you do this, you break the back of the curve we just saw, because when there’s only one method, there’s only one possible order it can be called in.You may not have thought about it in this way, but this pattern forces you to define a source of truth for every possible state your UI might find itself in and derive your view’s properties from that collective source of truth. If this sounds familiar, it’s because SwiftUI was directly inspired by this best practice. We’ve codified it in the framework by making “body” the only entry point that is ever called.</p>\n<p>This is why Views, but also Apps and Scenes and any other SwiftUI abstractions with a body work the way they do. Because you’re only human, and this pattern of simply fetching new instances for the parts of the UI that changed scales with your brain, virtually eliminating UI inconsistencies.</p>","frontmatter":{"title":"Basic of SwiftUI","date":"July 20, 2020","description":"This summarizes WWDC20 Session 'Introduction to SwiftUI(10119)'"}}},"pageContext":{"slug":"/swiftUIBasic/","previous":{"fields":{"slug":"/widgetBasic2/"},"frontmatter":{"title":"Basic of Widget2"}},"next":null}}}