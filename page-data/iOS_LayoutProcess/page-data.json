{"componentChunkName":"component---src-templates-blog-post-js","path":"/iOS_LayoutProcess/","result":{"data":{"site":{"siteMetadata":{"title":"KyooBlog"}},"markdownRemark":{"id":"4d3f2e06-0d8b-5c11-8893-ba2da339dce8","excerpt":"오토 레이아웃 기본 프로세스 In ‘The Layout Process’   오토 레이아웃을 통해 화면이 그려질 때, 아래 3가지 과정(Updating Constraints, Layout, Display)을 거쳐야 합니다.   1.Updating Constraints bottom-up…","html":"<h3>오토 레이아웃 기본 프로세스</h3>\n<blockquote>\n<p><a href=\"https://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/\">In ‘The Layout Process’</a></p>\n</blockquote>\n<p>  오토 레이아웃을 통해 화면이 그려질 때, 아래 3가지 과정(Updating Constraints, Layout, Display)을 거쳐야 합니다.  </p>\n<ul>\n<li>\n<p>1.Updating Constraints</p>\n<ul>\n<li>bottom-up으로 진행(subview → superview)</li>\n<li>2.layout과정에서 뷰 프레임을 설정하는 데 필요한 정보를 준비합니다.</li>\n</ul>\n</li>\n<li>\n<p>2.Layout</p>\n<ul>\n<li>top-down으로 진행(superview → subview)</li>\n<li>실제로 constraint system 결과를 뷰에 적용합니다. : OS X는 뷰의 프레임을 설정, iOS는 뷰의 bounds와 center를 설정.</li>\n</ul>\n</li>\n<li>\n<p>3.Display</p>\n<ul>\n<li>top-down으로 진행(superview → subview)</li>\n<li>오토레이아웃 사용여부와 관계없이, 뷰를 렌더합니다.  </li>\n</ul>\n</li>\n</ul>\n<p>각각의 과정은 이전 과정에 의존적입니다. 변화가 있는 layout이 아직 진행되지 않았다면, display과정이 이를 촉발시킵니다. 마찬가지로, 변화가 있는 updating constraints과정이 아직 진행되지 않았다면, layout과정이 이를 촉발시킵니다.<br>\n3가지 과정은 순차적인 단방향으로만 진행되지 않습니다. constraint를 사용하는 레이아웃 프로세스는 iterative 합니다. layout과정에서 이전 과정의 결과인 contraints를 변화시킬 수 있고, 이는 새로운 프로세스를 유발합니다. 이러한 방식으로 더 정교한 레이아웃 작업을 할 수도 있고, 무한반복에 빠질 수도 있습니다.  </p>\n<h3>Layout 변경이 발생하는 이벤트</h3>\n<blockquote>\n<p><a href=\"https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/CreatingViews/CreatingViews.html#//apple_ref/doc/uid/TP40009503-CH5-SW1\">ref1. In ‘Adjusting the Size and Position of Views at Runtime’</a>\n<a href=\"https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853-CH7-SW4\">ref2. In ‘Auto Layout Versus Frame-Based Layout’</a></p>\n</blockquote>\n<p>레이아웃은 아래의 이벤트가 발생할 때마다 변경된다.</p>\n<ul>\n<li>View의 bounds 사이즈 변경.</li>\n<li>root view의 변화를 유발하는 Interface Orientation의 변화.</li>\n<li>View Layer와 관련된 Core Animation sublayer가 변해, 레이아웃 업데이트가 필요할 때.</li>\n<li>애플리케이션에서 setNeedsLayout() / layoutIfNeeded()를 호출했을 때.</li>\n<li>애플리케이션에서 View의 레이어가 setNeedsLayout()를 호출했을 때.<br>\n</li>\n</ul>\n<p> superview의 레이아웃이 변경되었을 때, subviews의 사이즈와 위치도 조정해주어야 합니다. 자동 레이아웃을 설정하거나, 수동으로 레이아웃을 조정할 수 있습니다. 자동 레이아웃은 세밀한 부분까지 제어할 수 없고, external change에만 대응한다는 한계가 있습니다. 자동 레이아웃을 위해, superview의 autoresizesSubviews를 true로 설정하고 각각의 subview에 맞는 autoresizingMask를 설정합니다. 필요한 자동 autoresizing 규칙이 모든 뷰에 적용된 후, superview에 맞게 view를 수동으로 조정할 수 있습니다. 수동 조정을 통해 아래와 같은 변화를 줄 수 있습니다.</p>\n<ul>\n<li>조정중인 view의 사이즈나 위치의 변화</li>\n<li>subviews나 Core Animation layer 추가</li>\n<li>setNeedsDisplay나 setNeedsDisplayInRect 메소드 호출로, Display 새로 그리는 것을 강제</li>\n</ul>\n<h3>Layout 변화에 따라 수동으로 UI 그리기</h3>\n<blockquote>\n<p><a href=\"http://tech.gc.com/demystifying-ios-layout/\">ref1.Demystifying iOS Layout</a>\n<a href=\"https://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/\">ref2. In ‘The Layout Process’</a></p>\n</blockquote>\n<p> <code class=\"language-text\">ℹ️수동제어는 마지막으로 사용합시다. 자동제어 설정을 최대한 사용한 후에도, 원하는 UI 구현이 안될 때 수동으로 UI를 그립니다.</code></p>\n<p>수동으로 layout을 조정하려면, 조건별로 알맞은 메소드를 오버라이딩하거나 호출합니다. 조건은 ‘레이아웃 프로세스 중 조정이 필요한 과정, 조정이 필요한 시점’ 두 가지가 있습니다. 프로세스 과정을 고려할 때 이전 과정에서 조정할 수 있는 지 살펴보고, 어렵다면 다음 과정을 살펴봅니다. 예를 들어, 뷰 두개의 사이즈와 간격의 조정은 첫 과정인 Updating Constraints의 결과 값을 이용해야 하므로, Layout과정에서 처리합니다. 이후 해당 과정의 처리가 어느 시점에 필요한지 고려하여, 알맞은 메소드를 오버라이딩하거나 호출합니다. 먼저, 시점을 더 잘 이해하기 위해 업데이트 싸이클을 살펴봅시다.</p>\n<h4>The Update cycle. 업데이트 싸이클</h4>\n<p>업데이트 싸이클은 앱이 모든 이벤트 처리 코드를 실행한 후, 컨트롤이 Main Run Loop로 돌아가는 지점입니다. 이 지점에서 시스템이 Constraints, Layout, Display를 업데이트하기 시작합니다. 앱이 이벤트를 처리하는 동안 레이아웃 변경을 요청할 경우, 시스템은 해당 과정에서 업데이트가 필요하다고 표시해둡니다. 다음 업데이트 싸이클에서 시스템은 표시해둔 변경 사항을 실제로 업데이트 합니다.</p>\n<h4>시점 별 메소드 및 특징</h4>\n<table>\n<thead>\n<tr>\n<th>과정/시점</th>\n<th>A</th>\n<th>B</th>\n<th>C</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1. Updating Constraints</td>\n<td>setNeedsUpdateConstraints / invalidateIntrinsicContentSize</td>\n<td>updateConstraints</td>\n<td>updateConstraintsIfNeeded</td>\n</tr>\n<tr>\n<td>2. Layout</td>\n<td>setNeedsLayout</td>\n<td>layoutSubviews</td>\n<td>layoutIfNeeded</td>\n</tr>\n<tr>\n<td>3. Display</td>\n<td>setNeedsDisplay</td>\n<td>draw</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h5>A.시점</h5>\n<ul>\n<li>필요한 과정의 메소드를 호출합니다.</li>\n<li>A의 메소드를 호출하면,  시스템이 다음 업데이트 싸이클에서 해당 과정의 변경사항을 업데이트합니다.</li>\n</ul>\n<h5>B.시점</h5>\n<ul>\n<li>필요한 과정의 메소드를 UIView 클래스에서 오버라이딩합니다. 따라서 외부에서 직접 호출하지 않습니다.</li>\n<li>업데이트 사이클 진행 중 해당 과정의 제어권을 완벽히 가져, 어떠한 조정도 가능합니다. 따라서 퍼포먼스 이슈가 있을 수 있습니다.</li>\n</ul>\n<h5>C.시점</h5>\n<ul>\n<li>필요한 과정의 메소드를 호출합니다.</li>\n<li>C의 메소드를 호출하면, 변경사항이 즉시 업데이트됩니다. 따라서 다음 단계가 뷰 프레임의 최신 상태에 의존하는 경우 도움이 될 수 있습니다.</li>\n</ul>","frontmatter":{"title":"iOS Layout Process의 이해","date":"May 18, 2020","description":"오토 레이아웃을 통해 화면이 그려질 때, 3가지 과정(Updating Constraints, Layout, Display)을 거쳐야 합니다. 각각의 과정은 이전 과정에 의존적입니다. 레이아웃은 이벤트가 발생할 때마다 변경된다. 수동으로 layout을 조정하려면, 조건별로 알맞은 메소드를 오버라이딩하거나 호출합니다. 조건은 '레이아웃 프로세스 중 조정이 필요한 과정, 조정이 필요한 시점' 두 가지가 있습니다."}}},"pageContext":{"slug":"/iOS_LayoutProcess/","previous":{"fields":{"slug":"/UX_afterIPhone3/"},"frontmatter":{"title":"[책정리] 아이폰 이후의 UX 3(완)"}},"next":{"fields":{"slug":"/unpopular_oldVoice/"},"frontmatter":{"title":"인기 없는 늙은 목소리"}}}}}